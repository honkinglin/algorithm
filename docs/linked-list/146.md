# 146. LRU 缓存 <Badge type="warning" text="Medium" />

请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。

实现 LRUCache 类：

- LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
- void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。

函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。

>示例 1:  
输入   
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]   
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]   
输出   
[null, null, null, 1, null, -1, null, -1, 3, 4]   
解释
LRUCache lRUCache = new LRUCache(2);   
lRUCache.put(1, 1); // 缓存是 {1=1}   
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}   
lRUCache.get(1);    // 返回 1   
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}.  
lRUCache.get(2);    // 返回 -1 (未找到)   
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}   
lRUCache.get(1);    // 返回 -1 (未找到)   
lRUCache.get(3);    // 返回 3   
lRUCache.get(4);    // 返回 4   

## 解题思路
**输入：** 一个链表 `head`

**输出：** 对链表进行插入排序操作并返回最终排序后的表头

本题属于**链表插入与重排类**问题。

我们需要用到一个 `dummy` 节点，在每次对一个元素排好序之后都会指向最新数组的头节点

我们在排序过程中需要记录当前节点的下一个节点 `currNext = curr.next`

每次都从 `dummy` 节点开始遍历，记录为 `prev`，直到找到 `prev.next` 比 `curr.val` 要大的节点就停下来将当前节点插入该位置中 `prev -> curr -> prev.next`

之后继续从 `currNext` 开始遍历

最后返回 `dummy.next`

## 代码实现

::: code-group

```python
class Solution:
    def insertionSortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # 创建一个哑节点 dummy，方便后续统一插入逻辑
        dummy = ListNode(0)

        # curr 表示当前需要插入排序链表的节点
        curr = head

        # 遍历原链表
        while curr:
            # 保存当前节点的下一个节点，以便下一轮处理
            currNext = curr.next

            # 从 dummy 开始寻找合适的插入位置（prev 是 curr 的前驱）
            prev = dummy
            while prev.next and prev.next.val < curr.val:
                prev = prev.next  # 向后移动，直到找到第一个大于等于 curr 的位置

            # 完成插入：
            # 先保存 prev 原来的 next
            prevNext = prev.next

            # 把 curr 插到 prev 和 prevNext 之间
            prev.next = curr
            curr.next = prevNext

            # 继续处理原链表中的下一个节点
            curr = currNext

        # 返回排好序的链表头节点（dummy.next）
        return dummy.next
```

```javascript
var insertionSortList = function(head) {
    const dummy = new ListNode();

    let curr = head;
    while (curr != null) {
        let prev = dummy;
        const currNext = curr.next;

        while (prev.next && prev.next.val < curr.val) {
            prev = prev.next
        }

        prevNext = prev.next;
        prev.next = curr;
        curr.next = prevNext;
        curr = currNext;
    }

    return dummy.next;
};
```

:::

## 复杂度分析

时间复杂度：O(n ^ 2)

空间复杂度：O(1)

## 链接

[147 国际版](https://leetcode.com/problems/insertion-sort-list/description/)

[147 中文版](https://leetcode.cn/problems/insertion-sort-list/description/)

# 1010. 总持续时间可被 60 整除的歌曲 <Badge type="warning" text="Medium" />

在歌曲列表中，第 i 首歌曲的持续时间为 `time[i]` 秒。

返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望下标数字 i 和 j 满足  `i < j` 且有 `(time[i] + time[j]) % 60 == 0`。

>示例 1：  
输入：time = [30,20,150,100,40]   
输出：3   
解释：这三对的总持续时间可被 60 整除：   
(time[0] = 30, time[2] = 150): 总持续时间 180   
(time[1] = 20, time[3] = 100): 总持续时间 120  
(time[1] = 20, time[4] = 40): 总持续时间 60

>示例 2：  
输入：time = [60,60,60]   
输出：3   
解释：所有三对的总持续时间都是 120，可以被 60 整除。

## 解题思路

**输入**：一个整数数组 `time`

**输出**：返回可以组成和为 60 的倍数的组合数

本题属于 **哈希表 + 数组** 问题。

我们可以用哈希表或数组来保存数组中对 60 取模后 `mod` 的数量

当遍历的数字对 60 取模 `mod` 后能在哈希表中找到 `60 - mod` 的数量，则说明可以组成 60 的倍数 `res += count[60 - mod]`

每次都将当前值对 60 取模的值记录下来

## 代码实现

::: code-group

```python
class Solution:
    def numPairsDivisibleBy60(self, time: List[int]) -> int:
        count = [0] * 60  # 记录每个余数出现的次数
        res = 0

        for t in time:
            mod = t % 60
            complement = (60 - mod) % 60  # 互补余数

            # 当前时长可以与多少个“互补余数”配对
            res += count[complement]

            # 当前余数记录下来，供后面的人配对
            count[mod] += 1

        return res
```

```javascript
/**
 * @param {number[]} time
 * @return {number}
 */
var numPairsDivisibleBy60 = function(time) {
    const count = Array(60).fill(0);

    let ans = 0;
    for (let t of time) {
        const mod = t % 60;

        const complement = (60 - mod) % 60

        ans += count[complement];

        count[mod] += 1;
    }

    return ans;
};
```

:::

## 复杂度分析

时间复杂度：O(n)

空间复杂度：O(1)

## 链接

[1010 国际版](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/)

[1010 中文版](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/)

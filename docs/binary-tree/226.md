# 226. 翻转二叉树 <Badge type="tip" text="Easy" />

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

>示例 1:  
输入：root = [4,2,7,1,3,6,9]   
输出：[4,7,2,9,6,3,1]

![226-1](./assets/226-1.png)

>示例 2:  
输入：root = [2,1,3]   
输出：[2,3,1]

![226-2](./assets/226-2.png)

>示例 3:  
输入：root = []   
输出：[]

## 解题思路

**输入：** 一个二叉树的根节点 `root`。

**输出：** 翻转这棵二叉树返回根节点

本题属于**翻转二叉树**问题。

我们可以用 `dfs` 递归处理二叉树的每个节点

对当前节点执行左右子树交换，然后递归处理左右子节点。

根节点不变，但内部结构已被修改，因此直接返回 root 即可。

## 代码实现

::: code-group

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:        
        def dfs(node):
            # 🛑 递归终止条件：节点为空则直接返回
            if not node:
                return
            
            # 🔁 交换当前节点的左右子节点
            node.left, node.right = node.right, node.left

            # ⬇️ 递归翻转左右子树
            dfs(node.left)
            dfs(node.right)
        
        # 🚀 从根节点开始递归翻转整棵树
        dfs(root)

        # ✅ 返回翻转后的根节点
        return root
```

```javascript
var invertTree = function(root) {
    function dfs(node) {
        if (!node) return;

        [node.left, node.right] = [node.right, node.left]

        dfs(node.left)
        dfs(node.right)
    }

    dfs(root)

    return root;
};
```

:::

## 复杂度分析

时间复杂度：O(n)

空间复杂度：O(h)

## 链接

[226 国际版](https://leetcode.com/problems/invert-binary-tree/description/)

[226 中文版](https://leetcode.cn/problems/invert-binary-tree/description/)
